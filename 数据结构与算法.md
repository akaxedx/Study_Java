# 算法


## 时间复杂度

一次循环解决，时间复杂度:    
n
两次：                     
2n

2循环嵌套                  
n^2
3                      

二分法时间复杂度为
logn
....

## 排序方法

```java
排序方法        时间复杂度(最好)        时间复杂度(最坏)        时间复杂度(平均)
直接插入        O(n)                    O(n^2)                  O(n^2)
简单选择        O(n^2)                  O(n^2)                  O(n^2)
冒泡排序        O(n)                    O(n^2)                  O(n^2)
希尔排序        O(n)                    O(1.3)                  O(n^1.3)
快速排序        O(nlogn)                O(n^2)                  O(nlogn)
堆排序          O(nlogn)                O(nlogn)                O(nlogn)
归并排序        O(nlogn)                O(nlogn)                O(nlogn)
```

## 二分法查找

前提：数组必须有序

for循环可写，递归尝试

```java
package org.suanfa;

public class ErFen {
    public static void main(String[] args) {
        int[] arr = {1,3,6,10,40,55,67,84,99};
        System.out.println(getIndex(arr,arr.length-1,0,67));
    }
    public static int getIndex(int[] arr,int max,int min,int value){
        int middle = ( max + min ) / 2;
        if (max <= min && arr[middle]!=value){
            return -1;
        }else if (arr[middle] > value){
            return getIndex(arr,middle - 1, min, value);
        }else if (arr[middle] < value){
            return getIndex(arr ,max ,middle + 1, value);
        }else {
            return middle;
        }
    }
}

```

## 冒泡排序

简单使用fori循环

```java

package org.suanfa;

import java.util.Arrays;

public class MaoPao {
    public static void main(String[] args) {
        int[] arr = {7,5,6,9,3,4,9,5,1,3,6,4,8};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void change(int[] arr,int a,int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
    public static void sort(int[] arr){
        for (int j = 0; j < arr.length-1; j++) {
            for (int i = 0; i < arr.length-1-j; i++) {
                if(arr[i]>arr[i+1]){
                    change(arr,i,i+1);
                }
            }
        }
    }
}


```
## 选择排序

```java
package org.suanfa;

import java.util.Arrays;

public class Select {
    public static void main(String[] args) {
        int[] arr = {7,5,6,9,3,4,9,5,1,3,6,4,8};
        select(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void change(int[] arr,int a,int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
    public static void select(int[] arr){
        for (int j = 0; j < arr.length-1; j++) {
            for (int i = j + 1; i < arr.length; i++) {
                if(arr[j]>arr[i]){
                    change(arr,j,i);
                }
            }
        }
    }
}

```

## 递归

略

注意，超过18000左右会爆栈

## 快速排序递归实现

```java
package org.suanfa;

import java.util.Arrays;

public class Pace {
    public static void main(String[] args) {
        int[] arr = {7,5,6,9,3,4,9,5,1,3,6,4,8};
        pace(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
    public static void pace(int[] arr,int first,int end){
        if(first>=end){
            return;
        }
        int A = first;
        int B = end;
        int target = arr[first];
        while (A!=B) {
            while (arr[B] >= target&&B>A) {
                B--;
            }
            while (arr[A] <= target&&B>A) {
                A++;
            }
            change(arr,A,B);
        }
        change(arr,A,first);
        pace(arr,first,A-1);
        pace(arr,B+1,end);
    }
    public static void change(int[] arr,int a,int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}

```

# 数据结构

## 集合体系

Collection 单列集合顶层接口

set -- 接口 自动去重 没索引
    HashSet 类
    TreeSet 类
List -- 接口 不去重 有索引
    ArrayList 类
    LinkedList 类

Map 双列集合顶层接口
    HashMap 类
    TreeMap 类

#### Collection的共性

```java
package org.day05;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;


public class Utils {
    public static void main(String[] args) {
        /*Collection的共性
        * boolean add(E e)              添加元素
        * boolean remove(Object o)      从集合中移除指定元素
        * boolean removeIf(Predicate o) 根据条件进行删除
        * void clear()                  清空集合
        * boolean contains(Object o)    判断集合是否为空
        * int size()                    集合的长度，集合中元素的个数
        * */
        Collection<String> col = new ArrayList<>();//多态中，父类有的才可以调用
        col.add("abc");
        col.add("abc1");
        col.add("abc2");
        col.add("abc3");
        col.add("ab");
        col.add("a");
        col.remove("abc1");
        boolean bcd = col.remove("bcd");
        System.out.println(bcd);
       /* col.removeIf(new Predicate<String>() {
            @Override
            public boolean test(String s) { //s是col 集合中存储的元素
                return s.length()<4;
            }
        });*/
        //lambda表达式
        col.removeIf(s->s.length()<4);
        System.out.println(col);
        boolean abc = col.contains("abc");
        System.out.println(abc);
        col.clear();
        System.out.println(col);
        //......
    }
}

```

#### Collection 的共性 遍历 迭代器

```java
package org.day05;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.function.Predicate;


public class Utils {
    public static void main(String[] args) {

        Collection<String> col = new ArrayList<>();
        col.add("abc");
        col.add("abc1");
        col.add("abc2");
        col.add("abc3");
        col.add("abc4");
       /* for (int i = 0; i < col.size(); i++) {
            //System.out.println(col.get(i)); 报错捏 ArrayList不报错因为get是ArrayList的特有方法
            //共性遍历 "迭代器"

        }*/
        
        Iterator<String> iterator = col.iterator();
        //不用for循环
        /*
        for (int i = 0; i < col.size(); i++) {
            System.out.print(iterator.next()+" ");
        }*/
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}

```

#### 迭代器 remove

```java
package org.day05;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.function.Predicate;


public class Utils {
    public static void main(String[] args) {
        //ArrayList的删除
        ArrayList<String> al = new ArrayList<>();
        al.add("abc");
        al.add("a");
        al.add("a");
        al.add("a");
        al.add("abc4");
        for (int i = 0; i < al.size(); i++) {
            String s = al.get(i);
            if("a".equals(s)){
                al.remove(i);
                i--;
            }
        }
        System.out.println(al);

        ArrayList<String> al2 = new ArrayList<>();
        al2.add("abc");
        al2.add("a");
        al2.add("a");
        al2.add("a");
        al2.add("abc4");
        for (int i = al2.size() - 1; i >= 0; i--) {
            String s1 = al2.get(i);
            if("a".equals(s1)){
                al2.remove(i);
            }
        }
        System.out.println(al2);

        ArrayList<String> al3 = new ArrayList<>();
        al3.add("abc");
        al3.add("a");
        al3.add("a");
        al3.add("a");
        al3.add("abc4");
        while (al3.remove("a"));//时间复杂度太高 n^2
        System.out.println(al3);
        //Collection的删除 迭代器
        Collection<String> col = new ArrayList<>();
        col.add("abc");
        col.add("a");
        col.add("a");
        col.add("a");
        col.add("abc4");
        Iterator<String> iterator = col.iterator();
        while (iterator.hasNext()){
            String next = iterator.next();
            if(next.equals("a")){
                iterator.remove();
            }
        }
        System.out.println(col);
        //removeIf
        Collection<String> col2= new ArrayList<>();
        col2.add("abc");
        col2.add("a");
        col2.add("a");
        col2.add("a");
        col2.add("abc4");
        col2.removeIf(s->s.equals("a"));
        System.out.println(col2);
    }
}

```

#### java 用 增强 for 解决了迭代器复杂的问题


```java
package org.day05;


import java.util.ArrayList;
import java.util.Collection;


public class Utils {
    public static void main(String[] args) {
        Collection<String> col = new ArrayList<>();
        col.add("abc");
        col.add("a");
        col.add("a");
        col.add("a");
        col.add("abc4");
        for (String s : col) {
            System.out.println(s);
        }

    }
}

```

增强for底层是迭代器

所以具备迭代器的东西都可以被增强for遍历

只要实现了Iterable接口的都可以被增强for遍历




## 顺序表集合 ArrayList 集合

定长自定义集合：

```java

package org.day05;


import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;


public class Utils {
    public static void main(String[] args) {
        MyArrayList mal = new MyArrayList();
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");
        mal.add("a");

        for (String s : mal) {
            System.out.println(s);
        }
        /*增强for 的底层：
        Iterator<String> it = col.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        */
    }
}

class MyArrayList implements Iterable<String>{
    private String[] strs = new String[10];
    private int size = 0;
    public void add(String str){
        if(size>=10){
            throw new OverTenLengthException("此集合最多添加10个数据");
        }
        strs[size++] = str;
    }

    public int size(){
        return size;
    }

    public String get(int index){
        return strs[index];
    }

    @Override
    public Iterator<String> iterator() {
        //return null;
        return new Iterator<String>() {
            private int i = 0;
            @Override
            public boolean hasNext() {
                if(i>=size){
                    return false;
                }
                return true;
            }

            @Override
            public String next() {
                return strs[i++];
            }
        };
    }
}

class OverTenLengthException extends RuntimeException{
    public OverTenLengthException(){}
    public OverTenLengthException(String message){
        super(message);
    }
}

```












